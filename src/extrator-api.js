const axios = require('axios');
const supabase = require('./config/supabase');
require('dotenv').config();

class ExtratorAPI {
  constructor() {
    this.apiConsulta = 'https://pncp.gov.br/api/consulta/v1';
    this.apiIntegracao = 'https://pncp.gov.br/api/pncp/v1';
    this.limiteRegistros = 6500; // Limite m√°ximo
    this.registrosPorPagina = 50; // M√°ximo por p√°gina
    this.loteSupabase = 100; // Salvar de 100 em 100
    this.delayEntreRequisicoes = 300; // 300ms de delay entre requisi√ß√µes
  }

  // Fun√ß√£o para aguardar (delay)
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Fun√ß√£o para obter data de ontem
  obterDataOntem() {
    const hoje = new Date();
    hoje.setDate(hoje.getDate() - 1);
    
    const ano = hoje.getFullYear();
    const mes = String(hoje.getMonth() + 1).padStart(2, '0');
    const dia = String(hoje.getDate()).padStart(2, '0');
    
    return `${ano}${mes}${dia}`;
  }

  // Fun√ß√£o para obter data de N dias atr√°s no formato YYYYMMDD
  obterDataRetroativa(diasAtras) {
    const hoje = new Date();
    hoje.setDate(hoje.getDate() - diasAtras);
    
    const ano = hoje.getFullYear();
    const mes = String(hoje.getMonth() + 1).padStart(2, '0');
    const dia = String(hoje.getDate()).padStart(2, '0');
    
    return `${ano}${mes}${dia}`;
  }

  // Fun√ß√£o para buscar editais de um per√≠odo com pagina√ß√£o completa (todas as modalidades)
  async buscarEditaisData(dataInicial, dataFinal = null, limite = null) {
    const dataFinalUsar = dataFinal || dataInicial;
    console.log(`üîç Buscando editais do per√≠odo: ${dataInicial} at√© ${dataFinalUsar} (TODAS AS MODALIDADES)`);
    
    const url = `${this.apiConsulta}/contratacoes/publicacao`;
    const tamanhoPagina = 50; // M√°ximo permitido pela API
    let todosEditais = [];
    let totalElementos = 0;
    
    // Modalidades dispon√≠veis (baseado no teste anterior)
    const modalidades = [
      { codigo: 1, nome: 'Concorr√™ncia' },
      { codigo: 4, nome: 'Concurso' },
      { codigo: 5, nome: 'Leil√£o' },
      { codigo: 6, nome: 'Preg√£o Presencial' },
      { codigo: 7, nome: 'Preg√£o Eletr√¥nico' },
      { codigo: 8, nome: 'Dispensa' },
      { codigo: 9, nome: 'Inexigibilidade' }
    ];
    
    try {
      for (const modalidade of modalidades) {
        console.log(`\nüìã Buscando modalidade ${modalidade.codigo} (${modalidade.nome})...`);
        
        let pagina = 1;
        let editaisModalidade = [];
        
        do {
          console.log(`üìÑ P√°gina ${pagina} da modalidade ${modalidade.codigo}...`);
          
          const params = {
            dataInicial: dataInicial,
            dataFinal: dataFinalUsar,
            codigoModalidadeContratacao: modalidade.codigo,
            pagina: pagina,
            tamanhoPagina: tamanhoPagina
          };

          const response = await axios.get(url, { params });
          
          if (response.data && response.data.data) {
            const editaisPagina = response.data.data;
            editaisModalidade = editaisModalidade.concat(editaisPagina);
            totalElementos += response.data.totalRegistros || 0;
            
            console.log(`‚úÖ ${modalidade.nome}: ${editaisPagina.length} editais (Total modalidade: ${editaisModalidade.length})`);
            
            // Se n√£o h√° mais p√°ginas, para
            if (editaisPagina.length < tamanhoPagina) {
              console.log(`üìÑ √öltima p√°gina da modalidade ${modalidade.codigo} alcan√ßada`);
              break;
            }
            
            pagina++;
            
            // Delay entre p√°ginas para n√£o sobrecarregar a API
            await this.sleep(300);
            
          } else {
            console.log(`‚ö†Ô∏è Nenhum edital encontrado na modalidade ${modalidade.codigo}`);
            break;
          }
          
        } while (true);
        
        // Adicionar editais desta modalidade ao total
        todosEditais = todosEditais.concat(editaisModalidade);
        
        console.log(`üìä ${modalidade.nome}: ${editaisModalidade.length} editais adicionados`);
        console.log(`üìà Total acumulado: ${todosEditais.length} editais`);
        
        // Se atingiu o limite solicitado, para
        if (limite && todosEditais.length >= limite) {
          console.log(`üéØ Limite atingido: ${limite} editais`);
          todosEditais = todosEditais.slice(0, limite);
          break;
        }
        
        // Delay entre modalidades
        await this.sleep(500);
      }
      
      console.log(`üéâ Busca conclu√≠da: ${todosEditais.length} editais encontrados de todas as modalidades`);
      return { content: todosEditais, totalElements: totalElementos };
      
    } catch (error) {
      console.error('‚ùå Erro ao buscar editais:', error.message);
      throw error;
    }
  }

  // Fun√ß√£o para extrair dados b√°sicos
  async extrairDadosBasicos(cnpj, ano, sequencial) {
    const url = `${this.apiConsulta}/orgaos/${cnpj}/compras/${ano}/${sequencial}`;
    
    try {
      const response = await axios.get(url);
      return response.data;
    } catch (error) {
      console.error(`‚ùå Erro ao extrair dados b√°sicos: ${error.message}`);
      return null;
    }
  }

  // Fun√ß√£o para extrair itens
  async extrairItens(cnpj, ano, sequencial) {
    const url = `${this.apiIntegracao}/orgaos/${cnpj}/compras/${ano}/${sequencial}/itens`;
    
    try {
      await this.sleep(this.delayEntreRequisicoes); // Delay para evitar rate limit
      const response = await axios.get(url);
      return response.data;
    } catch (error) {
      console.error(`‚ùå Erro ao extrair itens: ${error.message}`);
      return [];
    }
  }

  // Fun√ß√£o para extrair documentos
  async extrairDocumentos(cnpj, ano, sequencial) {
    const url = `${this.apiIntegracao}/orgaos/${cnpj}/compras/${ano}/${sequencial}/arquivos`;
    
    try {
      await this.sleep(this.delayEntreRequisicoes); // Delay para evitar rate limit
      const response = await axios.get(url);
      return response.data;
    } catch (error) {
      console.error(`‚ùå Erro ao extrair documentos: ${error.message}`);
      return [];
    }
  }

  // Fun√ß√£o para extrair hist√≥rico
  async extrairHistorico(cnpj, ano, sequencial) {
    const url = `${this.apiIntegracao}/orgaos/${cnpj}/compras/${ano}/${sequencial}/historico`;
    
    try {
      await this.sleep(this.delayEntreRequisicoes); // Delay para evitar rate limit
      const response = await axios.get(url);
      return response.data;
    } catch (error) {
      console.error(`‚ùå Erro ao extrair hist√≥rico: ${error.message}`);
      return [];
    }
  }

  // Fun√ß√£o para extrair com retry individual
  async extrairComRetry(funcaoExtracao, tipo) {
    const maxTentativas = 3;
    let tentativa = 0;
    
    while (tentativa < maxTentativas) {
      try {
        const resultado = await funcaoExtracao();
        return resultado;
      } catch (error) {
        tentativa++;
        
        if (error.response && error.response.status === 429) {
          // Rate limit - aguardar mais tempo
          const tempoEspera = 2000 * tentativa; // 2s, 4s, 6s
          console.log(`‚è≥ Rate limit em ${tipo}, aguardando ${tempoEspera}ms...`);
          await this.sleep(tempoEspera);
        } else {
          // Outro erro - aguardar menos tempo
          await this.sleep(500 * tentativa);
        }
        
        if (tentativa >= maxTentativas) {
          console.error(`‚ùå Falha definitiva ao extrair ${tipo}: ${error.message}`);
          return []; // Retorna array vazio em caso de falha
        }
      }
    }
  }

  // Fun√ß√£o para extrair edital completo com retry
  async extrairEditalCompleto(edital) {
    const cnpj = edital.orgaoEntidade.cnpj;
    const ano = edital.anoCompra;
    const sequencial = edital.sequencialCompra;
    const numeroControle = edital.numeroControlePNCP;
    const razaoSocial = edital.orgaoEntidade.razaoSocial;
    
    console.log(`   üìå ${numeroControle} - ${razaoSocial}`);
    
    const startTime = Date.now();
    
    try {
      // Extrair dados b√°sicos
      const dadosBasicos = await this.extrairDadosBasicos(cnpj, ano, sequencial);
      
      // Extrair itens, documentos e hist√≥rico com retry
      const itens = await this.extrairComRetry(() => this.extrairItens(cnpj, ano, sequencial), 'itens');
      const documentos = await this.extrairComRetry(() => this.extrairDocumentos(cnpj, ano, sequencial), 'documentos');
      const historico = await this.extrairComRetry(() => this.extrairHistorico(cnpj, ano, sequencial), 'hist√≥rico');
      
      const tempo = ((Date.now() - startTime) / 1000).toFixed(2);
      
      return {
        numero_controle_pncp: numeroControle,
        cnpj_orgao: cnpj,
        razao_social: razaoSocial,
        municipio: edital.unidadeOrgao?.municipioNome,
        uf: edital.unidadeOrgao?.ufSigla,
        ano: ano,
        sequencial: sequencial,
        numero_compra: edital.numeroCompra,
        processo: edital.processo,
        objeto: edital.objetoCompra,
        modalidade: edital.modalidadeNome,
        situacao: edital.situacaoCompraNome,
        valor_estimado: edital.valorTotalEstimado,
        valor_homologado: edital.valorTotalHomologado,
        data_publicacao: edital.dataPublicacaoPncp,
        data_abertura: edital.dataAberturaProposta, // Usar do objeto original (lista)
        data_encerramento: edital.dataEncerramentoProposta, // Usar do objeto original (lista)
        itens: itens,
        documentos: documentos,
        historico: historico,
        data_extracao: new Date().toISOString(),
        fonte: 'API_PNCP',
        tempo_extracao: parseFloat(tempo),
        processado: true,
        tentativas_processamento: 0,
        ultimo_erro: null
      };
      
    } catch (error) {
      console.error(`   ‚ùå Erro ao processar edital: ${error.message}`);
      return null;
    }
  }

  // Fun√ß√£o para verificar editais j√° existentes
  async verificarEditaisExistentes(numerosControle) {
    try {
      const { data, error } = await supabase
        .from('editais_completos')
        .select('numero_controle_pncp')
        .in('numero_controle_pncp', numerosControle);
      
      if (error) {
        throw new Error(`Erro ao verificar editais existentes: ${error.message}`);
      }
      
      return new Set(data?.map(e => e.numero_controle_pncp) || []);
    } catch (error) {
      console.error('‚ùå Erro ao verificar editais existentes:', error.message);
      return new Set();
    }
  }

  // Fun√ß√£o para salvar editais no banco
  async salvarEditais(editais) {
    if (!editais || editais.length === 0) {
      return 0;
    }

    try {
      const { data, error } = await supabase
        .from('editais_completos')
        .upsert(editais, { 
          onConflict: 'numero_controle_pncp',
          ignoreDuplicates: false 
        });

      if (error) {
        throw new Error(`Erro ao salvar editais: ${error.message}`);
      }

      console.log(`   üíæ ${editais.length} editais salvos no banco`);
      return editais.length;
    } catch (error) {
      console.error('‚ùå Erro ao salvar editais:', error.message);
      throw error;
    }
  }

  // Fun√ß√£o principal de extra√ß√£o
  async extrairEditaisCompleto(opcoes = {}) {
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üéâ EXTRA√á√ÉO COMPLETA VIA API PNCP');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    const limite = opcoes.limite || 5600; // Limite padr√£o de 5600 editais
    const diasRetroativos = opcoes.diasRetroativos || 1; // Padr√£o: 1 dia (scheduler)
    
    let dataInicial, dataFinal;
    
    if (diasRetroativos === 1) {
      // Modo scheduler: apenas ontem
      dataInicial = this.obterDataOntem();
      dataFinal = dataInicial;
      console.log(`üìÖ Modo Scheduler: Data de ontem: ${dataInicial}`);
    } else {
      // Modo hist√≥rico: per√≠odo de N dias
      dataInicial = this.obterDataRetroativa(diasRetroativos);
      dataFinal = this.obterDataOntem();
      console.log(`üìÖ Modo Hist√≥rico: Per√≠odo de ${diasRetroativos} dias (${dataInicial} at√© ${dataFinal})`);
    }
    
    console.log(`üî¢ Limite configurado: ${limite} editais`);
    
    const startTime = Date.now();
    let totalEncontrados = 0;
    let totalNovos = 0;
    let totalAtualizados = 0;
    let totalErros = 0;
    
    try {
      // 1. Buscar editais do per√≠odo
      console.log('\nüîç ETAPA 1: Buscando editais do per√≠odo...');
      const resultado = await this.buscarEditaisData(dataInicial, dataFinal, limite);
      
      if (!resultado || !resultado.content || resultado.content.length === 0) {
        console.log('‚ùå Nenhum edital encontrado para ontem');
        return {
          status: 'concluido',
          mensagem: 'Nenhum edital encontrado para ontem',
          totalEncontrados: 0,
          totalNovos: 0,
          totalAtualizados: 0,
          totalErros: 0
        };
      }
      
      totalEncontrados = resultado.totalElements;
      console.log(`‚úÖ Encontrados ${resultado.content.length} editais (Total: ${totalEncontrados})`);
      
      // 2. Verificar editais j√° existentes
      console.log('\nüîç ETAPA 2: Verificando editais j√° existentes...');
      const numerosControle = resultado.content.map(e => e.numeroControlePNCP);
      const editaisExistentes = await this.verificarEditaisExistentes(numerosControle);
      
      console.log(`üìä Editais j√° existentes: ${editaisExistentes.size}`);
      console.log(`üìä Editais novos: ${numerosControle.length - editaisExistentes.size}`);
      
      // 3. Processar apenas editais novos (limitado ao par√¢metro limite)
      const editaisNovos = resultado.content
        .filter(e => !editaisExistentes.has(e.numeroControlePNCP))
        .slice(0, limite); // Limitar aos primeiros N editais
      
      if (editaisNovos.length === 0) {
        console.log('‚úÖ Todos os editais j√° est√£o na base de dados');
        return {
          status: 'concluido',
          mensagem: 'Todos os editais j√° est√£o na base de dados',
          totalEncontrados,
          totalNovos: 0,
          totalAtualizados: 0,
          totalErros: 0
        };
      }
      
      console.log(`\nüîç ETAPA 3: Processando ${editaisNovos.length} editais novos...`);
      
      // 4. Processar editais em lotes
      const lotes = [];
      for (let i = 0; i < editaisNovos.length; i += this.loteSupabase) {
        lotes.push(editaisNovos.slice(i, i + this.loteSupabase));
      }
      
      for (let i = 0; i < lotes.length; i++) {
        const lote = lotes[i];
        console.log(`\nüì¶ Processando lote ${i + 1}/${lotes.length} (${lote.length} editais)...`);
        
        const editaisProcessados = [];
        
        for (const edital of lote) {
          const editalCompleto = await this.extrairEditalCompleto(edital);
          
          if (editalCompleto) {
            editaisProcessados.push(editalCompleto);
            totalNovos++;
          } else {
            totalErros++;
          }
        }
        
        // Salvar lote no banco
        if (editaisProcessados.length > 0) {
          await this.salvarEditais(editaisProcessados);
        }
      }
      
      const tempoTotal = ((Date.now() - startTime) / 1000).toFixed(2);
      
      console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log('üìä RESUMO FINAL:');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log(`üìÖ Data: ${dataOntem}`);
      console.log(`‚è±Ô∏è Tempo total: ${tempoTotal}s`);
      console.log(`üìä Total encontrados: ${totalEncontrados}`);
      console.log(`‚úÖ Total novos: ${totalNovos}`);
      console.log(`üîÑ Total atualizados: ${totalAtualizados}`);
      console.log(`‚ùå Total erros: ${totalErros}`);
      
      return {
        status: 'concluido',
        mensagem: 'Extra√ß√£o conclu√≠da com sucesso',
        totalEncontrados,
        totalNovos,
        totalAtualizados,
        totalErros,
        tempoTotal: parseFloat(tempoTotal)
      };
      
    } catch (error) {
      console.error('‚ùå Erro geral:', error.message);
      throw error;
    }
  }
}

module.exports = ExtratorAPI;
